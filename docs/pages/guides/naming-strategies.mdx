# Naming Strategies

go-lightning converts Go struct and field names to database table and column names using a naming strategy. The default converts CamelCase to snake_case, but you can customize this.

## Default Naming Strategy

The built-in `DefaultDbNamingStrategy` applies these rules:

### Table Names

Struct name → snake_case + "s"

| Struct | Table |
|--------|-------|
| `User` | `users` |
| `OrderItem` | `order_items` |
| `HTTPRequest` | `h_t_t_p_requests` |

### Column Names

Field name → snake_case

| Field | Column |
|-------|--------|
| `Id` | `id` |
| `FirstName` | `first_name` |
| `CreatedAt` | `created_at` |
| `UserID` | `user_i_d` |

## The DbNamingStrategy Interface

```go
type DbNamingStrategy interface {
    GetTableNameFromStructName(string) string
    GetColumnNameFromStructName(string) string
}
```

## Custom Naming Strategy

Implement the interface to create your own naming rules:

### Example: Prefix Tables

```go
type PrefixedNamingStrategy struct {
    Prefix string
}

func (s PrefixedNamingStrategy) GetTableNameFromStructName(name string) string {
    return s.Prefix + toSnakeCase(name) + "s"
}

func (s PrefixedNamingStrategy) GetColumnNameFromStructName(name string) string {
    return toSnakeCase(name)
}

func toSnakeCase(s string) string {
    var result strings.Builder
    for i, r := range s {
        if unicode.IsUpper(r) {
            if i > 0 {
                result.WriteRune('_')
            }
            result.WriteRune(unicode.ToLower(r))
        } else {
            result.WriteRune(r)
        }
    }
    return result.String()
}

// Usage
lit.RegisterModelWithNaming[User](lit.PostgreSQL, PrefixedNamingStrategy{Prefix: "app_"})
// User → app_users
```

### Example: No Pluralization

```go
type SingularNamingStrategy struct{}

func (SingularNamingStrategy) GetTableNameFromStructName(name string) string {
    return toSnakeCase(name) // No "s" suffix
}

func (SingularNamingStrategy) GetColumnNameFromStructName(name string) string {
    return toSnakeCase(name)
}

// Usage
lit.RegisterModelWithNaming[User](lit.PostgreSQL, SingularNamingStrategy{})
// User → user
```

### Example: Uppercase Columns

```go
type UppercaseNamingStrategy struct{}

func (UppercaseNamingStrategy) GetTableNameFromStructName(name string) string {
    return strings.ToUpper(toSnakeCase(name)) + "S"
}

func (UppercaseNamingStrategy) GetColumnNameFromStructName(name string) string {
    return strings.ToUpper(toSnakeCase(name))
}

// Usage
lit.RegisterModelWithNaming[User](lit.PostgreSQL, UppercaseNamingStrategy{})
// User → USERS, FirstName → FIRST_NAME
```

## Using Different Strategies Per Model

Each model can have its own naming strategy:

```go
// Default naming for User
lit.RegisterModel[User](lit.PostgreSQL)
// User → users

// Custom naming for LegacyCustomer
lit.RegisterModelWithNaming[LegacyCustomer](lit.PostgreSQL, PrefixedNamingStrategy{Prefix: "legacy_"})
// LegacyCustomer → legacy_legacy_customers

// Different strategy for AuditLog
lit.RegisterModelWithNaming[AuditLog](lit.PostgreSQL, SingularNamingStrategy{})
// AuditLog → audit_log
```

## Common Patterns

### Match Existing Database Schema

When working with an existing database that doesn't follow snake_case:

```go
type ExactNamingStrategy struct {
    TableName string
    Columns   map[string]string
}

func (s ExactNamingStrategy) GetTableNameFromStructName(name string) string {
    return s.TableName
}

func (s ExactNamingStrategy) GetColumnNameFromStructName(name string) string {
    if col, ok := s.Columns[name]; ok {
        return col
    }
    return name
}

// Usage for a legacy table "TBL_USERS"
lit.RegisterModelWithNaming[User](lit.PostgreSQL, ExactNamingStrategy{
    TableName: "TBL_USERS",
    Columns: map[string]string{
        "Id":        "USER_ID",
        "FirstName": "FNAME",
        "LastName":  "LNAME",
        "Email":     "EMAIL_ADDR",
    },
})
```
